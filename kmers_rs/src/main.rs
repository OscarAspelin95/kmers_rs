#![feature(portable_simd)]
use std::{
    ops::BitOr,
    simd::{Simd, cmp::SimdOrd, u64x64},
    thread::panicking,
    u64, vec,
};

pub const BYTE_TO_SEQ: [u8; 256] = [
    0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

pub fn decode(byte: u64) -> u8 {
    if byte == 0 {
        return b'A';
    } else if byte == 1 {
        return b'C';
    } else if byte == 2 {
        return b'G';
    } else if byte == 3 {
        return b'T';
    } else {
        panic!("decoding failed")
    }
}
pub fn print_string(kmer: u64, k: usize) {
    let mut bytes = vec![];
    let mask = 3;
    for i in 0..k {
        let val = kmer >> 2 * i;
        let val = val & mask;
        bytes.push(decode(val));
    }
    dbg!(std::str::from_utf8(&bytes.into_iter().rev().collect::<Vec<u8>>()).unwrap());
}

// Generated by ChatGPT.
fn mm_hash64_simd(kmer: Simd<u64, 64>) -> Simd<u64, 64> {
    let mut key = kmer;

    let all_ones = Simd::splat(u64::MAX); // equivalent to !0
    key = all_ones ^ (key + (key << Simd::splat(21))); // Bitwise NOT via XOR
    key ^= key >> Simd::splat(24);
    key = (key + (key << Simd::splat(3))) + (key << Simd::splat(8)); // key * 265
    key ^= key >> Simd::splat(14);
    key = (key + (key << Simd::splat(2))) + (key << Simd::splat(4)); // key * 21
    key ^= key >> Simd::splat(28);
    key += key << Simd::splat(31);

    return key;
}

/// What we probably want to do is process each nt sequence separately, but use
/// SIMD acceleration for each nt sequence. We could use different SIMDs, but for a
/// nt string of sufficient length we can use u64x64, and chop it up into 64 parts
/// that we can process in parallel. Note that we need to take the last kmers into consideration
/// because the sequence length is probably not divisible by 64.

// fn forward_kmers(k: usize, string: &[u8]) {
//     // For now, runs 64 identical SIMD vectors.
//     let mut kmer = u64x64::splat(0);

//     for i in 0..string.len() {
//         let nt = BYTE_TO_SEQ[string[i] as usize] as u64;

//         kmer = (kmer << 2).bitor(u64x64::splat(nt));

//         // Print kmer from first SIMD (all 64 are the same at the moment).
//         if i >= k {
//             print_string(kmer.to_array()[0], k);
//         }
//     }
// }

// fn reverse_kmers(k: usize, string: &[u8]) {
//     // For now, runs 64 identical SIMD vectors.
//     let shift = ((k - 1) * 2) as u64;

//     let mut kmer = u64x64::splat(0);

//     for i in 0..string.len() {
//         let nt = BYTE_TO_SEQ[string[i] as usize] as u64;

//         let nt_rev = 3 - nt;

//         // Never....forget....the order of operations.
//         kmer = kmer >> 2;
//         kmer = kmer.bitor(u64x64::splat(nt_rev) << shift);

//         // Print kmer from first SIMD (all 64 are the same at the moment).
//         if i >= k as usize {
//             print_string(kmer.to_array()[0], k);
//         }
//     }
// }

/// Now, the "only" thing left to do is to make sure that the string
/// can be chopped up into 64 different pieces...
#[inline]
fn kmerize(k: usize, string: &[u8]) {
    // Initialize empty forward and reverse kmer.
    let mut kmer_fwd: std::simd::Simd<u64, 64> = u64x64::splat(0);
    let mut kmer_reverse = u64x64::splat(0);

    // Used for reverse kmer.
    let shift = ((k - 1) * 2) as u64;

    for i in 0..string.len() {
        let nt = BYTE_TO_SEQ[string[i] as usize] as u64;
        let nt_rev = 3 - nt;

        // Forward kmer
        kmer_fwd = (kmer_fwd << 2).bitor(u64x64::splat(nt));

        // Reverse kmer
        kmer_reverse = kmer_reverse >> 2;
        kmer_reverse = kmer_reverse.bitor(u64x64::splat(nt_rev) << shift);

        // We have a valid kmer.
        if i > k {
            // println!("Forward:");
            // print_string(kmer_fwd.to_array()[0], k);

            // println!("Reverse:");
            // print_string(kmer_reverse.to_array()[0], k);

            // Get the lexicographically smallest kmer out of fws/rev.
            let smallest = kmer_fwd.simd_min(kmer_reverse);

            // Here, we want to apply the hashing to each lane.
            let simd_hash = mm_hash64_simd(smallest);
        }
    }
}

/// In order to fully use the SIMD implementation, we need to take a nt string and chop it up into
/// equal length substrings that we can kmerize in parallel. However, in order to make sure we
/// get all kmers, we need to:
/// * Make sure substrings overlap by kmer_size-1 nucleotides.
/// * If we cannot evently divide the sequence into equal length parts, we need to
///     generate num_chunks + 1 chunks, where the last chunk can have arbitrary length > 0
///     and all previous chunks have the same length.
///
/// Example, we have a nt string we want to chop up into 64 parts with kmer_size-1 overlap
/// to extract every single kmer. If the nt string length cannot be evenly chopped up into
/// 64 subsequences of equal length, we need 65 chunks. 64 with equal length and the remaining
/// chunk to complete the length of nt string. Then, we can run the 64 equal length chunks
/// with SIMD kmerization and the last chunk with a non-SIMD kmerization.
#[inline]
fn chunkify_seq(seq_len: usize, num_chunks: usize, kmer_size: usize) -> Vec<Vec<usize>> {
    let chunk_len = (seq_len + ((num_chunks - 1) * (kmer_size - 1))) / num_chunks;

    if kmer_size > chunk_len {
        panic!(
            "Kmer size {} cannot be larger than chunk length {}. Choose smaller num_chunks.",
            num_chunks, kmer_size
        );
    }

    let mut start = 0;
    let mut end = chunk_len;

    // NOTE - we can probably make this a bit more streamlined by not having a
    // Vec<Vec> structure, but rather a Vec<(usize, usize)> structure.
    // However, this might not be the most computationally heavy step anyways.
    // Should benchmark this to see.
    let mut chunk_index: Vec<Vec<usize>> = Vec::with_capacity(num_chunks + 1);

    for _ in 0..num_chunks {
        chunk_index.push(vec![start, end]);

        start += chunk_len - kmer_size + 1;
        end = chunk_len + start;
    }

    chunk_index.push(vec![start, seq_len]);
    assert_eq!(chunk_index.len(), num_chunks + 1);

    return chunk_index;
}

/// Test function for kmerizing a single nt string (not binary format).
fn kmerize_single(nt_string: &str, kmer_size: usize) -> Vec<&str> {
    let mut kmers: Vec<&str> = vec![];

    for i in 0..nt_string.len() - kmer_size + 1 {
        kmers.push(&nt_string[i..i + kmer_size]);
    }

    return kmers;
}

/// Kmerize generated nt chunks.
fn kmerize_chunks(nt_string: &str, kmer_size: usize, chunks: Vec<Vec<usize>>) -> Vec<&str> {
    let mut kmers_total: Vec<&str> = vec![];

    chunks.iter().for_each(|chunk| {
        // Extract start, end pos.
        if chunk.len() != 2 {
            panic!();
        }
        let start = *chunk.first().unwrap();
        let end = *chunk.last().unwrap();

        let substring: &str = &nt_string[start..end];

        let mut kmers = kmerize_single(substring, kmer_size);

        kmers_total.append(&mut kmers);
    });
    return kmers_total;
}
fn main() {
    // Set kmer size to 21.
    let k = 7;
    let num_chunks = 3;
    // let nt_string = b"GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGC";

    // kmerize(k, nt_string);
    // TODO

    // Define nt string and kmerize the normal way.
    let nt_string = "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG";
    let kmers_single: Vec<&str> = kmerize_single(nt_string, k);

    // Split nt string into chunks and kmerize each chunk.
    let chunks = chunkify_seq(nt_string.len(), num_chunks, k);
    let kmers_chunk = kmerize_chunks(nt_string, k, chunks);

    assert_eq!(kmers_single, kmers_chunk);
}
